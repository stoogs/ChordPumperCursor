---
phase: 07-ux-polish-progression-workflow
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - src/ui/ProgressionStrip.h
  - src/ui/ProgressionStrip.cpp
  - src/ui/PluginEditor.cpp
  - src/midi/MidiFileBuilder.h
  - src/midi/MidiFileBuilder.cpp
autonomous: true
requirements: [UX-03, UX-04]

must_haves:
  truths:
    - "Clicking a chord in the progression strip plays that chord via MIDI output"
    - "An Export button on the strip saves the full progression as a multi-chord MIDI file"
    - "The MIDI file places each chord at successive bar boundaries (not all stacked at beat 1)"
    - "Export uses an async file dialog (no modal loops in plugin context)"
  artifacts:
    - path: "src/ui/ProgressionStrip.cpp"
      provides: "mouseDown click-to-play on strip slots and export button with FileChooser"
      contains: "getChordIndexAtPosition"
    - path: "src/midi/MidiFileBuilder.cpp"
      provides: "Multi-chord progression MIDI export"
      contains: "exportProgression"
    - path: "src/ui/PluginEditor.cpp"
      provides: "Wiring of onChordClicked to MIDI playback via MidiKeyboardState"
      contains: "onChordClicked"
  key_links:
    - from: "src/ui/ProgressionStrip.cpp"
      to: "onChordClicked callback"
      via: "mouseDown detects slot index, fires callback with chord"
      pattern: "onChordClicked"
    - from: "src/ui/PluginEditor.cpp"
      to: "MidiKeyboardState"
      via: "onChordClicked lambda calls noteOn + callAfterDelay noteOff"
      pattern: "noteOn.*noteOff"
    - from: "src/ui/ProgressionStrip.cpp"
      to: "MidiFileBuilder::exportProgression"
      via: "Export button click → FileChooser::launchAsync → exportProgression"
      pattern: "exportProgression"
---

<objective>
Add click-to-play on progression strip slots and a MIDI file export button, making the strip a fully interactive composition tool.

Purpose: Users can audition individual chords in their progression by clicking, and export the full sequence as a MIDI file for their DAW project.
Output: Clickable strip slots with MIDI playback, Export button with async file dialog, multi-chord MIDI file generation.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ux-polish-progression-workflow/07-RESEARCH.md
@.planning/phases/07-ux-polish-progression-workflow/07-01-SUMMARY.md

@src/ui/ProgressionStrip.h
@src/ui/ProgressionStrip.cpp
@src/ui/PluginEditor.h
@src/ui/PluginEditor.cpp
@src/midi/MidiFileBuilder.h
@src/midi/MidiFileBuilder.cpp
@src/ui/GridPanel.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Strip click-to-play with slot hit detection</name>
  <files>src/ui/ProgressionStrip.h, src/ui/ProgressionStrip.cpp, src/ui/PluginEditor.cpp</files>
  <action>
  **ProgressionStrip.h** — Add:
  - Public: `std::function<void(const Chord&)> onChordClicked;`
  - Public: `void mouseDown(const juce::MouseEvent& event) override;`
  - Private: `int getChordIndexAtPosition(juce::Point<int> pos) const;`

  **ProgressionStrip.cpp** — Implement `getChordIndexAtPosition`:
  - Compute slot geometry matching the existing paint() layout: `slotArea = getLocalBounds()` with right portion reserved for buttons (update to account for both Export and Clear buttons — roughly 120px from right). `slotWidth = (slotArea.getWidth() - (kMaxChords - 1) * 4) / kMaxChords`.
  - Given a point, compute `index = (pos.getX() - slotArea.getX()) / (slotWidth + 4)`.
  - Return -1 if pos is outside slotArea, if index < 0, if index >= chords.size(), or if the click falls in a 4px gap between slots.

  Implement `mouseDown`:
  - Guard against DnD-in-progress: `if (isReceivingDrag) return;` (uses the flag from Plan 01).
  - Also check: `if (auto* container = juce::DragAndDropContainer::findParentDragContainerFor(this)) { if (container->isDragAndDropActive()) return; }`
  - Call `getChordIndexAtPosition(event.getPosition())`. If >= 0, fire `onChordClicked(chords[index])`.

  **PluginEditor.cpp** — Wire `progressionStrip.onChordClicked` in constructor (after `addAndMakeVisible` calls):
  ```
  progressionStrip.onChordClicked = [this](const Chord& c) {
      auto& ks = processor.getKeyboardState();
      auto notes = c.midiNotes(4);
      for (auto n : notes) ks.noteOn(1, n, 0.8f);
      juce::Timer::callAfterDelay(300,
          [safeThis = juce::Component::SafePointer<ChordPumperEditor>(this), notes]() {
              if (safeThis == nullptr) return;
              auto& ks2 = safeThis->processor.getKeyboardState();
              for (auto n : notes) ks2.noteOff(1, n, 0.0f);
          });
  };
  ```
  Uses SafePointer for safety if editor is destroyed before the 300ms timer fires. No voice leading — strip playback uses basic `chord.midiNotes(4)` directly (per research recommendation: strip is for quick preview, not performance).
  </action>
  <verify>Build succeeds. Click on a filled strip slot — chord plays via MIDI. Click on an empty slot or gap — nothing happens. Click during an active drag — nothing happens.</verify>
  <done>Clicking a filled chord slot in the progression strip plays that chord via MIDI note-on/note-off with 300ms duration. Empty slots and gaps are ignored. Clicks during DnD are suppressed.</done>
</task>

<task type="auto">
  <name>Task 2: Multi-chord MIDI export with async FileChooser</name>
  <files>src/midi/MidiFileBuilder.h, src/midi/MidiFileBuilder.cpp, src/ui/ProgressionStrip.h, src/ui/ProgressionStrip.cpp</files>
  <action>
  **MidiFileBuilder.h** — Add public static method:
  `static bool exportProgression(const std::vector<Chord>& chords, int octave, const juce::File& file, float velocity = 0.8f);`

  **MidiFileBuilder.cpp** — Implement `exportProgression`:
  - Create a MidiMessageSequence. Add tempo meta event at tick 0.
  - For each chord at index `i`: compute `startTick = i * kBarLengthTicks`, `endTick = startTick + kBarLengthTicks`. Add noteOn for each MIDI note at startTick, noteOff at endTick (using `chord.midiNotes(octave)`).
  - Call `seq.updateMatchedPairs()`.
  - Use the existing `writeToFile(seq, file)` private helper to write.
  - Return the bool result from writeToFile.

  **ProgressionStrip.h** — Add:
  - Private: `juce::TextButton exportButton{"Export"};`
  - Private: `std::unique_ptr<juce::FileChooser> fileChooser;`
  - Private: `void exportProgression();`
  - Private: `void updateExportButton();`

  **ProgressionStrip.cpp** — Constructor:
  - `addAndMakeVisible(exportButton);`
  - `updateExportButton();` (disables when chords empty)
  - `exportButton.onClick = [this] { exportProgression(); };`

  Implement `updateExportButton`: `exportButton.setEnabled(!chords.empty());`
  Call `updateExportButton()` everywhere `updateClearButton()` is called (in addChord, setChords, clear, refreshFromState).

  Implement `exportProgression`:
  - If `chords.empty()` return early.
  - Create FileChooser as member: `fileChooser = std::make_unique<juce::FileChooser>("Export Progression as MIDI", juce::File::getSpecialLocation(juce::File::userHomeDirectory).getChildFile("ChordPumper-Progression.mid"), "*.mid", true, false, this);`
  - Launch with flags: `saveMode | canSelectFiles | warnAboutOverwriting` (values: 2 | 4 | 128 = 134, but use the FileBrowserComponent enum names).
  - In the async callback: `auto file = chooser.getResult(); if (file == juce::File()) return;` then `MidiFileBuilder::exportProgression(chords, 4, file);`

  Update `resized()` — Layout: `[8 chord slots] [Export button] [Clear button]`. Remove right 56px for Clear, then remove another 60px for Export with a 4px gap between them. So: `auto area = getLocalBounds(); clearButton.setBounds(area.removeFromRight(56).reduced(0, 4)); area.removeFromRight(4); exportButton.setBounds(area.removeFromRight(56).reduced(0, 4));`

  Update `paint()` — Adjust the slot area calculation to match: `auto slotArea = area.removeFromLeft(area.getWidth() - 120);` (was `-60`). This gives space for both buttons.

  Add `#include "midi/MidiFileBuilder.h"` to ProgressionStrip.cpp.
  </action>
  <verify>Build succeeds. Click Export with chords in strip — file dialog appears. Save file — .mid file created with chords at successive bar boundaries. Import into DAW — chords play sequentially, not stacked. Export disabled when strip is empty.</verify>
  <done>Export button visible next to Clear. Clicking Export opens async file dialog. Saved MIDI file contains progression with each chord at successive bar boundaries. Export button disabled when strip is empty.</done>
</task>

</tasks>

<verification>
1. Build: `cmake --build build-release` completes without errors
2. Strip click: Click filled slot → chord plays (MIDI note-on heard through instrument), click empty slot → silence
3. DnD guard: During a pad drag-over, clicking strip does nothing
4. Export basic: Add 3+ chords to strip, click Export → native file dialog appears
5. Export cancel: Click Cancel in dialog → no file created, no crash
6. Export write: Save → .mid file exists at chosen location, non-zero size
7. Export content: Import .mid into DAW → chords at bars 1, 2, 3... not all stacked
8. Export disabled: Clear strip → Export button grayed out
</verification>

<success_criteria>
- Strip slots are clickable and play the corresponding chord via MIDI
- Export button appears next to Clear, disabled when strip empty
- FileChooser uses launchAsync (no modal loops) with native dialog
- Exported MIDI file places chords at successive bar boundaries
- FileChooser stored as member variable (not stack — avoids premature destruction)
- All Plan 01 functionality preserved (DnD, click-to-play pads, external DnD)
</success_criteria>

<output>
After completion, create `.planning/phases/07-ux-polish-progression-workflow/07-02-SUMMARY.md`
</output>
