---
phase: 06-state-persistence-validation
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/PluginProcessor.h
  - src/PluginProcessor.cpp
  - src/ui/GridPanel.h
  - src/ui/GridPanel.cpp
  - src/ui/PluginEditor.h
  - src/ui/PluginEditor.cpp
  - src/ui/ProgressionStrip.h
  - src/ui/ProgressionStrip.cpp
autonomous: true
requirements: [PLAT-06]

must_haves:
  truths:
    - "Grid initializes from PersistentState on Editor creation — morphed grids are restored, not reset to chromatic palette"
    - "Progression strip shows the restored chord sequence on Editor creation"
    - "After padClicked, the morph results are written back to PersistentState"
    - "setStateInformation triggers Editor refresh so an open plugin window reflects restored state"
  artifacts:
    - path: "src/ui/GridPanel.h"
      provides: "GridPanel that initializes from and writes to PersistentState"
      contains: "PersistentState"
    - path: "src/ui/PluginEditor.cpp"
      provides: "Editor that refreshes all components on state restore notification"
      contains: "handleAsyncUpdate\\|changeListenerCallback"
    - path: "src/ui/ProgressionStrip.h"
      provides: "ProgressionStrip that initializes from PersistentState"
      contains: "setChords\\|loadFrom"
  key_links:
    - from: "src/ui/GridPanel.cpp"
      to: "src/PersistentState.h"
      via: "GridPanel constructor reads PersistentState for initial pad state"
      pattern: "getState\\(\\)"
    - from: "src/ui/GridPanel.cpp"
      to: "src/PersistentState.h"
      via: "padClicked writes morph results to PersistentState"
      pattern: "persistentState\\|getState"
    - from: "src/PluginProcessor.cpp"
      to: "src/ui/PluginEditor.cpp"
      via: "setStateInformation triggers sendChangeMessage, Editor receives changeListenerCallback"
      pattern: "sendChangeMessage\\|changeListenerCallback"
---

<objective>
Wire all Editor components (GridPanel, ProgressionStrip) to read from and write to the Processor's PersistentState, and add change notification so the Editor refreshes when the host restores state.

Purpose: Completes PLAT-06 by closing the loop — state is not just serialized but actually flows bidirectionally between Processor and Editor. Without this, state is serialized but the UI never reflects restored state.
Output: Working bidirectional state flow; Editor initializes from restored state; morph results persist through Editor interactions.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-state-persistence-validation/06-RESEARCH.md
@.planning/phases/06-state-persistence-validation/06-01-SUMMARY.md

@src/PluginProcessor.h
@src/PluginProcessor.cpp
@src/PersistentState.h
@src/ui/PluginEditor.h
@src/ui/PluginEditor.cpp
@src/ui/GridPanel.h
@src/ui/GridPanel.cpp
@src/ui/ProgressionStrip.h
@src/ui/ProgressionStrip.cpp
@src/ui/PadComponent.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add state change notification and wire GridPanel to PersistentState</name>
  <files>src/PluginProcessor.h, src/PluginProcessor.cpp, src/ui/GridPanel.h, src/ui/GridPanel.cpp</files>
  <action>
**Processor notification:**

Make ChordPumperProcessor inherit from `juce::ChangeBroadcaster` (in addition to AudioProcessor). In `setStateInformation`, after updating persistentState under the lock, call `sendChangeMessage()`. This dispatches a callback on the message thread to any registered ChangeListeners (i.e., the Editor).

**GridPanel state wiring:**

Modify GridPanel constructor signature to accept a reference to PersistentState and CriticalSection in addition to MidiKeyboardState:

```cpp
GridPanel(juce::MidiKeyboardState& keyboardState,
          PersistentState& state,
          juce::CriticalSection& stateLock);
```

Store `PersistentState& persistentState` and `juce::CriticalSection& stateLock` as members.

In the constructor, change initialization logic:
- If `persistentState.hasMorphed` is true, initialize each pad from `persistentState.gridChords[i]` and `persistentState.romanNumerals[i]`
- If `persistentState.hasMorphed` is false, use `chromaticPalette()` as before
- If `persistentState.lastVoicing` is non-empty, copy it to `activeNotes`

In `padClicked`, after morphEngine.morph() and the batch pad update loop, write the morph results back to PersistentState under the lock:

```cpp
{
    const juce::ScopedLock sl(stateLock);
    persistentState.lastPlayedChord = chord;
    persistentState.lastVoicing.assign(activeNotes.begin(), activeNotes.end());
    persistentState.hasMorphed = true;
    for (int i = 0; i < 32; ++i)
    {
        persistentState.gridChords[i] = suggestions[i].chord;
        persistentState.romanNumerals[i] = suggestions[i].romanNumeral;
    }
}
```

Also copy the MorphEngine weights from persistentState in the constructor: `morphEngine.weights = persistentState.weights;`

Add a public `refreshFromState()` method on GridPanel that re-reads PersistentState and updates all pads (same logic as constructor initialization). This will be called by the Editor on state restore notification.
  </action>
  <verify>
`cmake --build build --target ChordPumper_VST3 ChordPumper_CLAP ChordPumper_Standalone 2>&1 | tail -5` — all targets compile.
  </verify>
  <done>GridPanel reads PersistentState on construction and writes morph results back on padClicked. Processor sends change notification after setStateInformation. GridPanel has refreshFromState() for Editor-triggered refresh.</done>
</task>

<task type="auto">
  <name>Task 2: Wire ProgressionStrip and Editor to PersistentState</name>
  <files>src/ui/ProgressionStrip.h, src/ui/ProgressionStrip.cpp, src/ui/PluginEditor.h, src/ui/PluginEditor.cpp</files>
  <action>
**ProgressionStrip state wiring:**

Add a method `void setChords(const std::vector<Chord>& chords)` to ProgressionStrip that replaces the internal chord vector and repaints. This is used for initialization from PersistentState and for refresh on state restore.

Modify ProgressionStrip constructor to accept `PersistentState& state` and `juce::CriticalSection& stateLock`. Store references as members.

In the constructor, initialize from PersistentState:
```cpp
{
    const juce::ScopedLock sl(stateLock);
    chords = state.progression;
}
updateClearButton();
```

In `addChord`, after modifying `chords`, write back under the lock:
```cpp
{
    const juce::ScopedLock sl(stateLock);
    state.progression = chords;
}
```

In `clear`, after clearing `chords`, write back under the lock:
```cpp
{
    const juce::ScopedLock sl(stateLock);
    state.progression.clear();
}
```

Add a public `refreshFromState()` method that re-reads PersistentState and updates display:
```cpp
void ProgressionStrip::refreshFromState()
{
    {
        const juce::ScopedLock sl(stateLock);
        chords = persistentState.progression;
    }
    updateClearButton();
    repaint();
}
```

**Editor wiring:**

Make ChordPumperEditor inherit from `juce::ChangeListener` (in addition to AudioProcessorEditor and DragAndDropContainer).

In the constructor:
- Pass `processor.getState()` and `processor.getStateLock()` to GridPanel and ProgressionStrip constructors
- Register as change listener: `processor.addChangeListener(this)`

In destructor:
- Unregister: `processor.removeChangeListener(this)`

Implement `changeListenerCallback`:
```cpp
void ChordPumperEditor::changeListenerCallback(juce::ChangeBroadcaster*)
{
    gridPanel.refreshFromState();
    progressionStrip.refreshFromState();
}
```

Update the `onChordPlayed` callback wiring — it still fires `progressionStrip.addChord(c)` which now also persists to PersistentState through the strip's internal wiring.

Update `gridPanel` construction in the Editor's member initializer list to pass the new arguments: `gridPanel(p.getKeyboardState(), p.getState(), p.getStateLock())`.

Update `progressionStrip` construction similarly: `progressionStrip(p.getState(), p.getStateLock())`.
  </action>
  <verify>
`cmake --build build --target ChordPumper_VST3 ChordPumper_CLAP ChordPumper_Standalone 2>&1 | tail -5` — all targets compile. `cd build && ctest --output-on-failure` — all tests pass (no regressions). Launch standalone: `./build/ChordPumper_artefacts/Standalone/ChordPumper &` — verify grid loads with chromatic palette on first launch.
  </verify>
  <done>ProgressionStrip reads/writes PersistentState. Editor passes state refs to children, registers for change notification, and refreshes all components on state restore. Full bidirectional state flow operational.</done>
</task>

</tasks>

<verification>
1. Build succeeds for all three plugin formats
2. All existing tests pass (no regressions)
3. Launch standalone — grid shows chromatic palette on first load
4. Click pads to trigger morph, verify grid updates and progression strip records chords
5. Grep for `sendChangeMessage` in PluginProcessor.cpp — confirms notification wired
6. Grep for `changeListenerCallback` in PluginEditor.cpp — confirms Editor receives notification
</verification>

<success_criteria>
- GridPanel initializes pads from PersistentState (morphed grid restored, not reset)
- padClicked writes morph results back to PersistentState
- ProgressionStrip initializes from and writes back to PersistentState
- setStateInformation triggers Editor refresh via ChangeBroadcaster
- All existing tests pass, all three plugin formats compile
</success_criteria>

<output>
After completion, create `.planning/phases/06-state-persistence-validation/06-02-SUMMARY.md`
</output>
