---
phase: 06-state-persistence-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/PersistentState.h
  - src/PersistentState.cpp
  - src/PluginProcessor.h
  - src/PluginProcessor.cpp
  - tests/test_state.cpp
  - CMakeLists.txt
autonomous: true
requirements: [PLAT-06]

must_haves:
  truths:
    - "getStateInformation produces deterministic binary output for the same PersistentState"
    - "setStateInformation restores all fields from binary data produced by getStateInformation"
    - "State round-trip (serialize → deserialize → serialize) produces identical binary output"
    - "Corrupt or empty data in setStateInformation does not crash — fails gracefully to defaults"
  artifacts:
    - path: "src/PersistentState.h"
      provides: "PersistentState struct with toValueTree/fromValueTree"
      contains: "struct PersistentState"
    - path: "src/PersistentState.cpp"
      provides: "ValueTree serialization/deserialization implementation"
      contains: "toValueTree"
    - path: "src/PluginProcessor.cpp"
      provides: "getStateInformation and setStateInformation using PersistentState"
      contains: "copyXmlToBinary"
    - path: "tests/test_state.cpp"
      provides: "Catch2 round-trip tests for state serialization"
      contains: "TEST_CASE"
  key_links:
    - from: "src/PluginProcessor.cpp"
      to: "src/PersistentState.h"
      via: "getStateInformation calls persistentState.toValueTree()"
      pattern: "toValueTree"
    - from: "src/PluginProcessor.cpp"
      to: "src/PersistentState.h"
      via: "setStateInformation calls PersistentState::fromValueTree()"
      pattern: "fromValueTree"
    - from: "tests/test_state.cpp"
      to: "src/PersistentState.h"
      via: "tests exercise toValueTree/fromValueTree round-trip"
      pattern: "toValueTree.*fromValueTree"
---

<objective>
Implement PersistentState struct and ValueTree-based serialization so the plugin can save and restore all state through getStateInformation/setStateInformation.

Purpose: This is the foundation for PLAT-06 — without serialization, the DAW cannot persist plugin state across sessions. Also required for pluginval state tests at level 2+.
Output: PersistentState struct, working serialization/deserialization, Catch2 round-trip tests.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-state-persistence-validation/06-RESEARCH.md

@src/PluginProcessor.h
@src/PluginProcessor.cpp
@src/engine/Chord.h
@src/engine/PitchClass.h
@src/engine/ChordType.h
@src/engine/NoteLetter.h
@src/engine/MorphEngine.h
@CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PersistentState struct with ValueTree serialization</name>
  <files>src/PersistentState.h, src/PersistentState.cpp, src/PluginProcessor.h, src/PluginProcessor.cpp, CMakeLists.txt</files>
  <action>
Create `src/PersistentState.h` defining the struct and `src/PersistentState.cpp` implementing ValueTree serialization. The struct captures ALL serializable plugin state:

```cpp
struct PersistentState {
    std::array<Chord, 32> gridChords;       // current pad chords
    std::array<std::string, 32> romanNumerals; // Roman numeral labels
    Chord lastPlayedChord;                   // morph reference chord
    std::vector<int> lastVoicing;            // voice-led MIDI notes
    std::vector<Chord> progression;          // progression strip (up to 8)
    MorphWeights weights;                    // morph scoring weights
    bool hasMorphed = false;                 // distinguishes initial palette from morphed grid

    juce::ValueTree toValueTree() const;
    static PersistentState fromValueTree(const juce::ValueTree& tree);
};
```

PersistentState.h includes: `engine/Chord.h`, `engine/MorphEngine.h` (for MorphWeights), `<juce_data_structures/juce_data_structures.h>`, `<array>`, `<string>`, `<vector>`.

Implement `toValueTree()` in PersistentState.cpp:
- Root node type: `"ChordPumperState"` with property `"version"` = 1 (int, `kCurrentStateVersion`)
- Child `"Grid"` with 32 `"Pad"` children, each having properties: `"index"` (int), `"root"` (int, cast from NoteLetter), `"accidental"` (int, from int8_t), `"type"` (int, cast from ChordType), `"roman"` (juce::String from std::string)
- Child `"MorphContext"` (only if `hasMorphed`): `"root"`, `"accidental"`, `"type"` for lastPlayedChord, plus `"voicing"` as comma-separated MIDI note ints (juce::String)
- Child `"Progression"` with N `"Chord"` children (same root/accidental/type properties)
- Child `"Weights"` with float properties: `"diatonic"`, `"commonTones"`, `"voiceLeading"`

Implement `fromValueTree()`:
- Validate root type is `"ChordPumperState"` and `"version"` >= 1. Return default PersistentState if invalid.
- Parse `"Grid"` children: use `"index"` property to place each pad (don't assume ordering). Cast int properties back to NoteLetter, int8_t, ChordType. Read `"roman"` as std::string.
- Parse `"MorphContext"` if present: set `hasMorphed = true`, read chord and voicing. Parse voicing string with `juce::StringArray::fromTokens(voicingStr, ",", "")`.
- Parse `"Progression"` children into vector.
- Parse `"Weights"` with defaults matching MorphWeights defaults (0.40, 0.25, 0.25).

Initialize `gridChords` to chromatic palette as default (include `midi/ChromaticPalette.h`). This ensures a fresh PersistentState matches the visual default.

Update `src/PluginProcessor.h`:
- Add `#include "PersistentState.h"` and `#include <juce_core/juce_core.h>` (for CriticalSection)
- Add private members: `PersistentState persistentState;` and `juce::CriticalSection stateLock;`
- Add public accessor: `PersistentState& getState() { return persistentState; }` and `const PersistentState& getState() const { return persistentState; }`
- Add public accessor: `juce::CriticalSection& getStateLock() { return stateLock; }`

Update `src/PluginProcessor.cpp` — implement getStateInformation:
```cpp
void ChordPumperProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    juce::ValueTree state;
    {
        const juce::ScopedLock sl(stateLock);
        state = persistentState.toValueTree();
    }
    if (auto xml = state.createXml())
        copyXmlToBinary(*xml, destData);
}
```

Implement setStateInformation:
```cpp
void ChordPumperProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    auto xml = getXmlFromBinary(data, sizeInBytes);
    if (xml == nullptr) return;

    auto tree = juce::ValueTree::fromXml(*xml);
    if (!tree.isValid()) return;

    auto restored = PersistentState::fromValueTree(tree);
    {
        const juce::ScopedLock sl(stateLock);
        persistentState = std::move(restored);
    }
}
```

Add `src/PersistentState.cpp` to both the plugin target (`target_sources(ChordPumper PRIVATE ...)`) and the test target (`add_executable(ChordPumperTests ...)`) in CMakeLists.txt.

Add `juce::juce_data_structures` to the test target's `target_link_libraries` (needed for ValueTree in tests).
  </action>
  <verify>
`cmake --build build --target ChordPumper_VST3 ChordPumper_CLAP ChordPumper_Standalone 2>&1 | tail -5` — all three format targets compile without errors. `cmake --build build --target ChordPumperTests 2>&1 | tail -5` — test binary compiles.
  </verify>
  <done>PersistentState struct exists with toValueTree/fromValueTree. getStateInformation/setStateInformation in Processor serialize/deserialize via ValueTree with version tagging and CriticalSection thread safety. Both plugin and test targets compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: State round-trip unit tests</name>
  <files>tests/test_state.cpp, CMakeLists.txt</files>
  <action>
Create `tests/test_state.cpp` with Catch2 tests exercising PersistentState serialization.

Add `tests/test_state.cpp` to the `add_executable(ChordPumperTests ...)` sources in CMakeLists.txt.

Test cases:

1. **"Default state round-trips"** — Default-constructed PersistentState → toValueTree → fromValueTree. Verify `hasMorphed == false`, `progression.empty()`, weights match defaults (0.40, 0.25, 0.25), grid has 32 chords (chromatic palette defaults).

2. **"Populated state round-trips"** — Set up known state: assign specific chords to grid positions (e.g., index 0 = C Major, index 1 = Dm, index 5 = F#aug), set Roman numerals for those positions ("I", "ii", "IV#"), set `hasMorphed = true`, `lastPlayedChord = {pitches::C, ChordType::Major}`, `lastVoicing = {60, 64, 67}`, add 3 chords to progression, set custom weights (0.5, 0.3, 0.2). Round-trip and verify every field.

3. **"ValueTree determinism"** — Populated state → toValueTree → fromValueTree → toValueTree. Compare the two ValueTrees using `tree1.isEquivalentTo(tree2)`. This tests that serialization is deterministic (needed for pluginval level 8 binary equality).

4. **"Corrupt data handling"** — Call `fromValueTree(juce::ValueTree())` (invalid tree) → verify returns default state, no crash. Call `fromValueTree(juce::ValueTree("WrongType"))` → verify returns default state. Call fromValueTree with a tree that has `"version"` = 0 → verify returns default state.

5. **"Missing children handled gracefully"** — Create a valid `"ChordPumperState"` tree with version=1 but no child nodes. Verify fromValueTree returns default state for all fields without crashing.

6. **"Partial state restores available fields"** — Create a tree with only `"Grid"` and `"Weights"` children (no MorphContext, no Progression). Verify grid and weights are restored, hasMorphed is false, progression is empty.

Use `REQUIRE` assertions. Import from `engine/PitchClass.h` (pitches namespace), `engine/Chord.h`, `engine/ChordType.h`.
  </action>
  <verify>
`cd build && ctest --test-dir . -R "state" --output-on-failure` — all state tests pass. `ctest --test-dir . --output-on-failure` — ALL existing tests still pass (no regressions).
  </verify>
  <done>6 Catch2 test cases for state serialization pass. Default round-trip, populated round-trip, determinism, corrupt data, missing children, and partial state all verified. No regressions in existing tests.</done>
</task>

</tasks>

<verification>
1. `cmake --build build 2>&1 | tail -3` — full build succeeds
2. `cd build && ctest --output-on-failure` — all tests pass including new state tests
3. Grep for `copyXmlToBinary` in PluginProcessor.cpp — confirms serialization is wired
4. Grep for `kCurrentStateVersion` in PersistentState — confirms version tagging exists
</verification>

<success_criteria>
- PersistentState struct captures all serializable plugin state (32 grid chords, Roman numerals, morph context, progression, weights)
- ValueTree serialization produces deterministic output with version=1 tag
- Deserialization handles corrupt/empty/partial data gracefully
- CriticalSection protects state access for thread safety
- 6+ Catch2 tests pass covering round-trip, determinism, and error cases
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-state-persistence-validation/06-01-SUMMARY.md`
</output>
