---
phase: 09-chord-depth-ui-polish
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/ProgressionStrip.h
  - src/ui/ProgressionStrip.cpp
autonomous: true
requirements:
  - DEPTH-03

must_haves:
  truths:
    - "User can drag a chord in the progression strip and drop it at a different position"
    - "Dragging shows a visible 3px insertion cursor between slots at the target position"
    - "Dropping reorders the chord in-place — the chord moves, not appends"
    - "Reorder drag does not trigger the pad-drag code path (distinct drag source)"
    - "Dropping a pad chord onto the strip still appends as before"
    - "Progression state (persistentState.progression) is updated after reorder"
  artifacts:
    - path: "src/ui/ProgressionStrip.h"
      provides: "reorderDragFromIndex, insertionIndex fields; mouseDrag() declaration; itemDragMove() declaration"
      contains: "reorderDragFromIndex"
    - path: "src/ui/ProgressionStrip.cpp"
      provides: "mouseDrag(), itemDragMove(), updated itemDropped(), updated itemDragExit(), insertion cursor in paint()"
      contains: "REORDER:"
  key_links:
    - from: "ProgressionStrip::mouseDrag()"
      to: "DragAndDropContainer::startDragging()"
      via: "drag description string with REORDER:N prefix"
      pattern: "REORDER:"
    - from: "ProgressionStrip::itemDropped()"
      to: "chords vector erase+insert"
      via: "parse fromIdx from REORDER: prefix, compute corrected toIdx"
      pattern: "erase.*insert|fromIdx|toIdx"
    - from: "ProgressionStrip::paint()"
      to: "insertionIndex field"
      via: "3px vertical cursor drawn between slots at insertionIndex"
      pattern: "insertionIndex"
---

<objective>
Enable drag-to-reorder within the progression strip so users can rearrange chord slots without clearing and re-adding.

Purpose: Currently dragging a strip chord does nothing useful — the drag threshold is only reached from pad drags. This plan adds initiation of an intra-strip reorder drag from mouseDown+mouseDrag on the strip itself, visual insertion cursor feedback, and correct erase+insert reorder logic in itemDropped().

Output: Updated ProgressionStrip.h with new fields; updated ProgressionStrip.cpp with full reorder drag lifecycle.
</objective>

<execution_context>
@/home/stoo/.claude/get-shit-done/workflows/execute-plan.md
@/home/stoo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/ui/ProgressionStrip.h
@src/ui/ProgressionStrip.cpp
@src/ui/PadComponent.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reorder drag fields and mouseDrag() to ProgressionStrip</name>
  <files>
    src/ui/ProgressionStrip.h
    src/ui/ProgressionStrip.cpp
  </files>
  <action>
**ProgressionStrip.h — add to private section:**
```cpp
int reorderDragFromIndex = -1;
int insertionIndex = -1;
void mouseDrag(const juce::MouseEvent& event) override;
void itemDragMove(const SourceDetails& details) override;
int insertionIndexAtX(int xPos) const;  // maps pixel x to slot gap index (0..N)
```

**ProgressionStrip.cpp — implement insertionIndexAtX():**
This helper returns which gap (0 = before first slot, N = after last slot) an x-coordinate falls closest to. Use the same slot width calculation as paint() and getChordIndexAtPosition():

```cpp
int ProgressionStrip::insertionIndexAtX(int xPos) const
{
    auto area = getLocalBounds();
    auto slotArea = area.removeFromLeft(area.getWidth() - 120);
    auto slotWidth = (slotArea.getWidth() - (kMaxChords - 1) * 4) / kMaxChords;
    int relX = xPos - slotArea.getX();
    // Each cell = slotWidth + 4 gap. Map relX to nearest gap boundary.
    int cellWidth = slotWidth + 4;
    // Clamp relX to slot area
    relX = juce::jlimit(0, slotArea.getWidth(), relX);
    // Number of complete cells before this position
    int cell = relX / cellWidth;
    int posInCell = relX % cellWidth;
    // If we're in the second half of a cell, insertion is after it
    int insertion = (posInCell > cellWidth / 2) ? cell + 1 : cell;
    return juce::jlimit(0, static_cast<int>(chords.size()), insertion);
}
```

**ProgressionStrip.cpp — implement mouseDrag():**
```cpp
void ProgressionStrip::mouseDrag(const juce::MouseEvent& event)
{
    // 10px threshold — wider than pad's 6px to avoid accidental reorder on click
    if (event.getDistanceFromDragStart() < 10)
        return;

    if (reorderDragFromIndex >= 0)
        return;  // already dragging

    int index = getChordIndexAtPosition(event.getMouseDownPosition());
    if (index < 0)
        return;

    reorderDragFromIndex = index;

    if (auto* container = juce::DragAndDropContainer::findParentDragContainerFor(this))
    {
        juce::String desc = "REORDER:" + juce::String(index);
        container->startDragging(juce::var(desc), this, juce::ScaledImage{}, false);
    }
}
```

**ProgressionStrip.cpp — implement itemDragMove():**
```cpp
void ProgressionStrip::itemDragMove(const SourceDetails& details)
{
    juce::String desc = details.description.toString();
    if (!desc.startsWith("REORDER:"))
        return;

    auto localPos = getLocalPoint(details.sourceComponent.get(), details.localPosition);
    insertionIndex = insertionIndexAtX(localPos.getX());
    repaint();
}
```

After adding these, build to confirm compilation.
  </action>
  <verify>cmake --build /home/stoo/code/GSD/Plugins/ChordPumperCursor/build-release --config Release -j$(nproc) 2>&1 | tail -5</verify>
  <done>Build succeeds. ProgressionStrip.h declares reorderDragFromIndex, insertionIndex, mouseDrag(), itemDragMove(), insertionIndexAtX(). ProgressionStrip.cpp implements them all.</done>
</task>

<task type="auto">
  <name>Task 2: Reorder drop logic, insertion cursor paint, drag exit, and isInterestedInDragSource update</name>
  <files>src/ui/ProgressionStrip.cpp</files>
  <action>
**isInterestedInDragSource() — accept REORDER: prefix in addition to PadComponent:**
```cpp
bool ProgressionStrip::isInterestedInDragSource(const SourceDetails& details)
{
    juce::String desc = details.description.toString();
    if (desc.startsWith("REORDER:"))
        return true;
    return dynamic_cast<PadComponent*>(details.sourceComponent.get()) != nullptr;
}
```

**itemDropped() — handle REORDER: prefix before existing pad-drop logic:**
```cpp
void ProgressionStrip::itemDropped(const SourceDetails& details)
{
    juce::String desc = details.description.toString();

    if (desc.startsWith("REORDER:"))
    {
        int fromIdx = desc.fromFirstOccurrenceOf(":", false, false).getIntValue();
        int toIdx   = insertionIndex;  // gap index (0..N) set by itemDragMove

        // Validate indices
        if (fromIdx >= 0 && fromIdx < static_cast<int>(chords.size()) &&
            toIdx   >= 0 && toIdx   <= static_cast<int>(chords.size()) &&
            toIdx != fromIdx && toIdx != fromIdx + 1)
        {
            auto chord = chords[static_cast<size_t>(fromIdx)];
            chords.erase(chords.begin() + fromIdx);
            // After erase, if toIdx was after fromIdx, it shifts back by 1
            if (toIdx > fromIdx)
                toIdx--;
            chords.insert(chords.begin() + toIdx, chord);

            {
                const juce::ScopedLock sl(stateLock);
                persistentState.progression = chords;
            }
            updateClearButton();
            updateExportButton();
        }

        reorderDragFromIndex = -1;
        insertionIndex = -1;
        isReceivingDrag = false;
        repaint();
        return;
    }

    // Existing pad-drop logic (unchanged)
    if (auto* pad = dynamic_cast<PadComponent*>(details.sourceComponent.get()))
    {
        const auto& chord = pad->getChord();
        addChord(chord);
        if (onChordDropped)
            onChordDropped(chord);
    }
    isReceivingDrag = false;
    repaint();
}
```

**itemDragExit() — reset reorder state:**
```cpp
void ProgressionStrip::itemDragExit(const SourceDetails& details)
{
    juce::String desc = details.description.toString();
    if (desc.startsWith("REORDER:"))
    {
        reorderDragFromIndex = -1;
        insertionIndex = -1;
    }
    isReceivingDrag = false;
    repaint();
}
```

**paint() — draw insertion cursor when insertionIndex >= 0:**
In paint(), after the chord slot loop and before the isReceivingDrag overlay, add:

```cpp
if (insertionIndex >= 0 && insertionIndex <= static_cast<int>(chords.size()))
{
    auto area2 = getLocalBounds();
    auto slotArea2 = area2.removeFromLeft(area2.getWidth() - 120);
    auto slotWidth2 = (slotArea2.getWidth() - (kMaxChords - 1) * 4) / kMaxChords;
    int cellWidth2 = slotWidth2 + 4;
    // Cursor x = left edge of insertion gap
    int cursorX = slotArea2.getX() + insertionIndex * cellWidth2 - 2;
    g.setColour(juce::Colour(0xff6c8ebf));  // blue accent (same as pressed colour)
    g.fillRect(cursorX, slotArea2.getY() + 2, 3, slotArea2.getHeight() - 4);
}
```

After all changes, do a full release build. Fix any compilation errors before marking complete.
  </action>
  <verify>cmake --build /home/stoo/code/GSD/Plugins/ChordPumperCursor/build-release --config Release -j$(nproc) 2>&1 | tail -5</verify>
  <done>
Release build succeeds. Plugin installed to ~/.vst3 and ~/.clap.
In the running plugin:
- With 2+ chords in the strip, dragging a chord slot shows a blue 3px insertion cursor moving between slots
- Releasing the drag reorders the chord to the cursor position
- Dropping a grid pad onto the strip still appends as before
- Persistence: after reorder, strip state survives plugin reload
  </done>
</task>

</tasks>

<verification>
1. Build clean: no errors
2. grep confirms REORDER prefix: `grep "REORDER:" src/ui/ProgressionStrip.cpp | wc -l` returns 5+
3. grep confirms insertion cursor: `grep "insertionIndex" src/ui/ProgressionStrip.cpp | wc -l` returns 6+
4. grep confirms erase+insert: `grep "erase\|insert" src/ui/ProgressionStrip.cpp`
5. grep confirms fromIdx toIdx correction: `grep "toIdx > fromIdx" src/ui/ProgressionStrip.cpp`
</verification>

<success_criteria>
- Drag a chord in the strip: 3px blue insertion cursor follows mouse between slots
- Drop reorders the chord (not appends)
- Drop at same position or adjacent position is a no-op
- Pad drag onto strip still appends
- State persists: reordered progression survives host session reload
- Release build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/09-chord-depth-ui-polish/09-03-SUMMARY.md`
</output>
