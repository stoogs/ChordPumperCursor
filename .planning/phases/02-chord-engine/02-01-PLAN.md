---
phase: 02-chord-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CMakeLists.txt
  - src/engine/NoteLetter.h
  - src/engine/PitchClass.h
  - src/engine/PitchClass.cpp
  - src/engine/ChordType.h
  - src/engine/Chord.h
  - src/engine/Chord.cpp
  - tests/test_pitch_class.cpp
  - tests/test_chord.cpp
  - tests/test_chord_naming.cpp
autonomous: true
requirements: [CHRD-01, CHRD-02]

must_haves:
  truths:
    - "ChordPumperEngine static library compiles with no JUCE dependency"
    - "ChordPumper plugin links against ChordPumperEngine and still builds all formats"
    - "Catch2 test target builds and runs trivial smoke tests"
  artifacts:
    - path: "src/engine/NoteLetter.h"
      provides: "Note letter enum, semitone lookup table, letter name table"
      contains: "enum class NoteLetter"
    - path: "src/engine/PitchClass.h"
      provides: "PitchClass struct with letter+accidental, 12 canonical constants"
      contains: "struct PitchClass"
    - path: "src/engine/ChordType.h"
      provides: "ChordType enum, constexpr interval table, suffix table, noteCount()"
      contains: "enum class ChordType"
    - path: "src/engine/Chord.h"
      provides: "Chord struct with root+type, methods for noteCount/midiNotes/name"
      contains: "struct Chord"
    - path: "src/engine/Chord.cpp"
      provides: "Chord method stubs (compilable, not yet correct)"
    - path: "src/engine/PitchClass.cpp"
      provides: "PitchClass method stubs (compilable, not yet correct)"
  key_links:
    - from: "CMakeLists.txt"
      to: "ChordPumperEngine"
      via: "add_library + target_link_libraries"
      pattern: "target_link_libraries.*ChordPumperEngine"
    - from: "CMakeLists.txt"
      to: "Catch2"
      via: "FetchContent_Declare + FetchContent_MakeAvailable"
      pattern: "FetchContent_Declare.*Catch2"
    - from: "CMakeLists.txt"
      to: "ChordPumperTests"
      via: "add_executable + catch_discover_tests"
      pattern: "catch_discover_tests.*ChordPumperTests"
---

<objective>
Create the ChordPumperEngine static library (JUCE-independent) and Catch2 v3 test infrastructure. All engine header files contain complete type definitions (enums, lookup tables, struct interfaces). Implementation files contain compilable stubs. Test files contain trivial smoke tests to verify the build pipeline.

Purpose: Establish the build foundation that Plans 02-02 (PitchClass TDD) and 02-03 (Chord TDD) will fill with real logic and exhaustive tests. The static library pattern decouples the theory engine from JUCE, enabling fast test compilation.

Output: Compilable engine library, linked plugin, passing smoke tests.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chord-engine/02-RESEARCH.md
@CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChordPumperEngine static library with complete type definitions</name>
  <files>
    CMakeLists.txt
    src/engine/NoteLetter.h
    src/engine/PitchClass.h
    src/engine/PitchClass.cpp
    src/engine/ChordType.h
    src/engine/Chord.h
    src/engine/Chord.cpp
  </files>
  <action>
    Create the engine source files and integrate as a CMake static library. Delete src/engine/.gitkeep (replaced by real files).

    **src/engine/NoteLetter.h** — Complete, no further changes needed after this task:
    - `#pragma once`, `#include <array>`, `#include <cstdint>`
    - `namespace chordpumper`
    - `enum class NoteLetter : uint8_t { C, D, E, F, G, A, B };`
    - `inline constexpr std::array<int, 7> kNaturalSemitones = {0, 2, 4, 5, 7, 9, 11};`
    - `inline constexpr std::array<const char*, 7> kLetterNames = {"C", "D", "E", "F", "G", "A", "B"};`

    **src/engine/ChordType.h** — Complete, no further changes needed after this task:
    - `#pragma once`, `#include <array>`, `#include <cstdint>`
    - `namespace chordpumper`
    - `enum class ChordType : uint8_t { Major, Minor, Diminished, Augmented, Maj7, Min7, Dom7, Dim7, HalfDim7 };`
    - `inline constexpr std::array<std::array<int, 4>, 9> kIntervals` — full interval table from research:
      `{{0,4,7,-1}, {0,3,7,-1}, {0,3,6,-1}, {0,4,8,-1}, {0,4,7,11}, {0,3,7,10}, {0,4,7,10}, {0,3,6,9}, {0,3,6,10}}`
    - `inline constexpr std::array<const char*, 9> kChordSuffix = {"", "m", "dim", "aug", "maj7", "m7", "7", "dim7", "m7b5"};`
    - `inline constexpr int noteCount(ChordType type) { return (static_cast<int>(type) < 4) ? 3 : 4; }`

    **src/engine/PitchClass.h** — Full interface, stub inline constexpr:
    - `#pragma once`, includes for NoteLetter.h, `<string>`, `<cstdint>`
    - `namespace chordpumper`
    - `struct PitchClass` with:
      - `NoteLetter letter; int8_t accidental;`
      - `constexpr int semitone() const { return 0; }` (stub — Plan 02-02 replaces)
      - `std::string name() const;` (declared, defined in .cpp)
      - `int midiNote(int octave) const;` (declared, defined in .cpp)
      - `constexpr bool operator==(const PitchClass&) const = default;`
    - `namespace pitches` with 12 inline constexpr constants: C{C,0}, Cs{C,1}, D{D,0}, Eb{E,-1}, E{E,0}, F{F,0}, Fs{F,1}, G{G,0}, Ab{A,-1}, A{A,0}, Bb{B,-1}, B{B,0}

    **src/engine/PitchClass.cpp** — Stubs:
    - `#include "engine/PitchClass.h"`
    - `namespace chordpumper {`
    - `std::string PitchClass::name() const { return ""; }`
    - `int PitchClass::midiNote(int octave) const { return 0; }`
    - `}`

    **src/engine/Chord.h** — Full interface:
    - `#pragma once`, includes for PitchClass.h, ChordType.h, `<vector>`, `<string>`
    - `namespace chordpumper`
    - `struct Chord` with:
      - `PitchClass root; ChordType type;`
      - `int noteCount() const;`
      - `std::vector<int> midiNotes(int octave) const;`
      - `std::string name() const;`

    **src/engine/Chord.cpp** — Stubs:
    - `#include "engine/Chord.h"`
    - `namespace chordpumper {`
    - `int Chord::noteCount() const { return 0; }`
    - `std::vector<int> Chord::midiNotes(int octave) const { return {}; }`
    - `std::string Chord::name() const { return ""; }`
    - `}`

    **CMakeLists.txt** — Add engine library BEFORE the juce_add_plugin call:
    ```cmake
    add_library(ChordPumperEngine STATIC
        src/engine/PitchClass.cpp
        src/engine/Chord.cpp
    )
    target_include_directories(ChordPumperEngine PUBLIC src)
    target_compile_features(ChordPumperEngine PUBLIC cxx_std_20)
    ```
    Add to plugin link libraries: `ChordPumperEngine` in the existing target_link_libraries PRIVATE section.
  </action>
  <verify>
    ```bash
    cmake --preset debug 2>&1 | tail -5
    cmake --build build/debug --target ChordPumperEngine 2>&1 | tail -5
    cmake --build build/debug --target ChordPumper_Standalone 2>&1 | tail -5
    ```
    All three commands exit 0. Engine library compiles independently. Plugin still builds with engine linked.
  </verify>
  <done>
    ChordPumperEngine static library compiles. All 6 engine header/source files exist with complete type definitions (enums, tables) and compilable stub implementations. Plugin builds and links against the engine.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Catch2 v3.13.0 via FetchContent and create test target with smoke tests</name>
  <files>
    CMakeLists.txt
    tests/test_pitch_class.cpp
    tests/test_chord.cpp
    tests/test_chord_naming.cpp
  </files>
  <action>
    Add Catch2 and a test executable to CMakeLists.txt, guarded by an option so tests don't build during normal plugin builds.

    **CMakeLists.txt** — Append after all plugin configuration (after the CLAP post-build copy):
    ```cmake
    option(CHORDPUMPER_BUILD_TESTS "Build unit tests" ON)

    if(CHORDPUMPER_BUILD_TESTS)
        include(FetchContent)
        FetchContent_Declare(
            Catch2
            GIT_REPOSITORY https://github.com/catchorg/Catch2.git
            GIT_TAG v3.13.0
            GIT_SHALLOW TRUE
        )
        FetchContent_MakeAvailable(Catch2)

        list(APPEND CMAKE_MODULE_PATH ${catch2_SOURCE_DIR}/extras)
        include(CTest)
        include(Catch)

        add_executable(ChordPumperTests
            tests/test_pitch_class.cpp
            tests/test_chord.cpp
            tests/test_chord_naming.cpp
        )
        target_link_libraries(ChordPumperTests PRIVATE
            ChordPumperEngine
            Catch2::Catch2WithMain
        )
        catch_discover_tests(ChordPumperTests)
    endif()
    ```

    **tests/test_pitch_class.cpp** — Trivial smoke test:
    ```cpp
    #include <catch2/catch_test_macros.hpp>
    #include "engine/PitchClass.h"

    using namespace chordpumper;

    TEST_CASE("PitchClass smoke test", "[pitch]") {
        PitchClass c{NoteLetter::C, 0};
        REQUIRE(c.letter == NoteLetter::C);
        REQUIRE(c.accidental == 0);
    }
    ```

    **tests/test_chord.cpp** — Trivial smoke test:
    ```cpp
    #include <catch2/catch_test_macros.hpp>
    #include "engine/Chord.h"

    using namespace chordpumper;

    TEST_CASE("Chord smoke test", "[chord]") {
        Chord chord{pitches::C, ChordType::Major};
        REQUIRE(chord.root == pitches::C);
        REQUIRE(chord.type == ChordType::Major);
    }
    ```

    **tests/test_chord_naming.cpp** — Trivial smoke test:
    ```cpp
    #include <catch2/catch_test_macros.hpp>
    #include "engine/Chord.h"

    using namespace chordpumper;

    TEST_CASE("Chord naming smoke test", "[chord][naming]") {
        Chord chord{pitches::C, ChordType::Major};
        // Stub returns "" — just verifying it doesn't crash
        auto name = chord.name();
        REQUIRE(name.size() >= 0);
    }
    ```

    Create the tests/ directory if it doesn't exist.
  </action>
  <verify>
    ```bash
    cmake --preset debug 2>&1 | tail -5
    cmake --build build/debug --target ChordPumperTests 2>&1 | tail -5
    cd build/debug && ctest --output-on-failure 2>&1
    ```
    CMake configures (fetches Catch2 on first run). Test binary builds. CTest discovers and runs 3 tests — all pass. No JUCE headers appear in test compilation commands.
  </verify>
  <done>
    Catch2 v3.13.0 integrated via FetchContent. ChordPumperTests executable builds and links against ChordPumperEngine + Catch2 (no JUCE). Three smoke tests discovered by CTest and passing.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build/debug --target ChordPumperEngine` exits 0 — engine compiles standalone
2. `cmake --build build/debug --target ChordPumper_Standalone` exits 0 — plugin still builds with engine linked
3. `cmake --build build/debug --target ChordPumperTests` exits 0 — test binary compiles
4. `cd build/debug && ctest --output-on-failure` — 3 tests discovered, 3 pass
5. No `#include <juce_` or `#include "juce_` in any src/engine/ file
</verification>

<success_criteria>
- Engine library (ChordPumperEngine) is a JUCE-independent C++20 static library
- All type definitions complete: NoteLetter enum, PitchClass struct, ChordType enum with interval/suffix tables, Chord struct
- Plugin target links engine and builds all formats (VST3, CLAP, Standalone)
- Catch2 test target builds and runs smoke tests via CTest
- Build infrastructure ready for TDD in Plans 02-02 and 02-03
</success_criteria>

<output>
After completion, create `.planning/phases/02-chord-engine/02-01-SUMMARY.md`
</output>
