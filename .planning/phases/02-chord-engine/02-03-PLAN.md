---
phase: 02-chord-engine
plan: 03
type: tdd
wave: 3
depends_on: [02-02]
files_modified:
  - src/engine/Chord.h
  - src/engine/Chord.cpp
  - tests/test_chord.cpp
  - tests/test_chord_naming.cpp
autonomous: true
requirements: [CHRD-01, CHRD-02]

must_haves:
  truths:
    - "All 9 chord types constructible from any of the 12 canonical roots (108 combinations)"
    - "Triads produce 3 notes, seventh chords produce 4 notes"
    - "All 108 chord MIDI note arrays contain correct semitone intervals from root"
    - "All 108 chord names match pop/jazz convention (e.g., 'Dm7', 'F#aug', 'Bbmaj7', 'C')"
    - "Catch2 test suite covers all 108 combinations exhaustively"
  artifacts:
    - path: "src/engine/Chord.cpp"
      provides: "Working Chord implementations for noteCount, midiNotes, name"
      min_lines: 20
    - path: "tests/test_chord.cpp"
      provides: "Exhaustive chord construction tests using GENERATE for 108 combinations"
      min_lines: 50
    - path: "tests/test_chord_naming.cpp"
      provides: "Chord naming tests with specific examples and all-roots coverage"
      min_lines: 40
  key_links:
    - from: "src/engine/Chord.cpp"
      to: "src/engine/PitchClass.h"
      via: "PitchClass::midiNote() called in Chord::midiNotes()"
      pattern: "root\\.midiNote"
    - from: "src/engine/Chord.cpp"
      to: "src/engine/ChordType.h"
      via: "kIntervals lookup in midiNotes(), kChordSuffix in name()"
      pattern: "kIntervals\\[static_cast<int>\\(type\\)\\]"
    - from: "src/engine/Chord.cpp"
      to: "src/engine/PitchClass.h"
      via: "PitchClass::name() called in Chord::name()"
      pattern: "root\\.name\\(\\)"
---

<objective>
Implement Chord construction, MIDI note generation, and chord naming using test-driven development. This directly satisfies CHRD-01 (all chord types constructible) and CHRD-02 (correct chord names displayed). Exhaustive testing of all 108 combinations (9 types × 12 roots) ensures zero gaps.

Purpose: TDD with GENERATE macros guarantees every chord type/root combination is covered. The interval lookup table and suffix table (already in ChordType.h from Plan 02-01) are the source of truth — implementation is wiring them through Chord methods.

Output: Working, tested Chord with all 108 type/root combinations producing correct note counts, MIDI notes, and display names.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chord-engine/02-RESEARCH.md
@src/engine/ChordType.h
@src/engine/Chord.h
@src/engine/Chord.cpp
@src/engine/PitchClass.h
@tests/test_chord.cpp
@tests/test_chord_naming.cpp
</context>

<feature>
  <name>Chord — Construction, Interval Application, MIDI Generation, Naming</name>
  <files>tests/test_chord.cpp, tests/test_chord_naming.cpp, src/engine/Chord.h, src/engine/Chord.cpp</files>
  <behavior>
    Chord represents a musical chord as PitchClass root + ChordType type.

    **noteCount() → int:**
    - Major, Minor, Diminished, Augmented → 3
    - Maj7, Min7, Dom7, Dim7, HalfDim7 → 4

    **midiNotes(octave) → std::vector&lt;int&gt;:**
    - C Major at octave 4 → [60, 64, 67]
    - C Minor at octave 4 → [60, 63, 67]
    - C Diminished at octave 4 → [60, 63, 66]
    - C Augmented at octave 4 → [60, 64, 68]
    - C Maj7 at octave 4 → [60, 64, 67, 71]
    - C Min7 at octave 4 → [60, 63, 67, 70]
    - C Dom7 at octave 4 → [60, 64, 67, 70]
    - C Dim7 at octave 4 → [60, 63, 66, 69]
    - C HalfDim7 at octave 4 → [60, 63, 66, 70]
    - F# Major at octave 4 → [66, 70, 73]
    - Bb Min7 at octave 4 → [70, 73, 77, 80]
    - All 108 combinations: root.midiNote(octave) + each interval from kIntervals

    **name() → std::string:**
    - C + Major → "C"
    - C + Minor → "Cm"
    - D + Min7 → "Dm7" (matches CHRD-02 example)
    - F# + Augmented → "F#aug" (matches CHRD-02 example)
    - Bb + Maj7 → "Bbmaj7"
    - B + HalfDim7 → "Bm7b5"
    - Ab + Dim7 → "Abdim7"
    - G + Dom7 → "G7"
    - All 108: root.name() + kChordSuffix[type]

    **Test structure:**
    test_chord.cpp uses GENERATE over all 12 roots × all 9 types:
    - Verify noteCount() matches expected (3 or 4)
    - Verify midiNotes().size() == noteCount()
    - Verify specific interval relationships within midiNotes()
    - Verify midiNotes()[0] == root.midiNote(octave) for all combinations

    test_chord_naming.cpp:
    - Explicit CHECK for each of the 9 chord types with C root (spot-check suffixes)
    - Explicit CHECK for CHRD-02 examples: "Dm7", "F#aug"
    - GENERATE over all 12 roots × all 9 types: verify name starts with root.name()
    - GENERATE over all 12 roots with Major type: verify name == root.name() (no suffix)
  </behavior>
  <implementation>
    **RED phase — write failing tests:**
    Replace smoke tests in test_chord.cpp and test_chord_naming.cpp with comprehensive tests.

    test_chord.cpp:
    - TEST_CASE "Triads produce 3 notes" — GENERATE 12 roots × 4 triad types, REQUIRE noteCount()==3 and midiNotes(4).size()==3
    - TEST_CASE "Seventh chords produce 4 notes" — GENERATE 12 roots × 5 seventh types, REQUIRE noteCount()==4 and midiNotes(4).size()==4
    - TEST_CASE "C major MIDI notes at octave 4" — REQUIRE midiNotes == {60, 64, 67}
    - TEST_CASE "All chord MIDI notes start with root" — GENERATE all 108, REQUIRE midiNotes(4)[0] == root.midiNote(4)
    - TEST_CASE "Chord intervals match lookup table" — GENERATE all 108, verify each note is root + interval offset

    test_chord_naming.cpp:
    - TEST_CASE "Chord name spot checks" — CHECK all 9 types with C root: "C","Cm","Cdim","Caug","Cmaj7","Cm7","C7","Cdim7","Cm7b5"
    - TEST_CASE "CHRD-02 example names" — CHECK Dm7=="Dm7", F#aug=="F#aug"
    - TEST_CASE "Major chords have no suffix" — GENERATE 12 roots, CHECK name() == root.name()
    - TEST_CASE "All chord names start with root name" — GENERATE all 108, CHECK name starts with root.name()

    Run tests — they MUST fail (stubs return wrong values).

    **GREEN phase — implement in Chord.cpp:**
    - noteCount(): `return chordpumper::noteCount(type);` (delegates to free function in ChordType.h)
    - midiNotes(octave):
      ```
      int rootMidi = root.midiNote(octave);
      auto& intervals = kIntervals[static_cast<int>(type)];
      int count = noteCount();
      std::vector<int> notes;
      notes.reserve(count);
      for (int i = 0; i < count; ++i)
          notes.push_back(rootMidi + intervals[i]);
      return notes;
      ```
    - name(): `return root.name() + kChordSuffix[static_cast<int>(type)];`

    Run tests — they MUST all pass.

    **REFACTOR phase (if needed):**
    Consider whether Chord::noteCount() should be constexpr. Clean up includes. No functional changes.
  </implementation>
</feature>

<verification>
1. `cmake --build build/debug --target ChordPumperTests` exits 0
2. `cd build/debug && ctest --output-on-failure` — ALL tests pass (PitchClass + Chord + Naming)
3. Test count should be significantly higher than Plan 02-02 (108+ chord combinations via GENERATE)
4. Specific CHRD-02 examples verified: Dm7 name == "Dm7", F#aug name == "F#aug"
5. Plugin still builds: `cmake --build build/debug --target ChordPumper_Standalone` exits 0
</verification>

<success_criteria>
- All 9 chord types × 12 roots (108 combinations) produce correct note counts and MIDI notes
- All 108 chord names match pop/jazz convention
- CHRD-02 examples ("Dm7", "F#aug") explicitly verified
- Catch2 exhaustive tests pass via CTest
- Plugin builds with engine linked — no regressions
- Phase 2 requirements CHRD-01 and CHRD-02 fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-chord-engine/02-03-SUMMARY.md`
</output>
